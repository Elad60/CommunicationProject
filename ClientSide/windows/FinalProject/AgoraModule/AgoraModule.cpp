#include "pch.h"
#include "AgoraModule.h"
#include <windows.h>
#include <string>
#include <memory>
#include <mutex>

namespace winrt::FinalProject::implementation
{
    // Use Agora namespace for convenience
    using namespace agora::rtc;


    
    // Initialize singleton
    AgoraManager* AgoraManager::instance = nullptr;
    std::mutex AgoraManager::mutex_;
    

    
    // AgoraEventHandler implementation
    void AgoraEventHandler::onJoinChannelSuccess(const char* channel, uid_t uid, int elapsed)
    {
        std::string msg = "‚úÖ Successfully joined channel: " + std::string(channel) + 
                         " with UID: " + std::to_string(uid) + 
                         " in " + std::to_string(elapsed) + "ms";
        OutputDebugStringA(("AgoraEventHandler::onJoinChannelSuccess - " + msg + "\n").c_str());
    }

    void AgoraEventHandler::onLeaveChannel(const RtcStats& stats)
    {
        std::string msg = "‚úÖ Successfully left channel. Duration: " + std::to_string(stats.duration) + "s";
        OutputDebugStringA(("AgoraEventHandler::onLeaveChannel - " + msg + "\n").c_str());
    }

    void AgoraEventHandler::onUserJoined(uid_t uid, int elapsed)
    {
        std::string msg = "üë§ User joined: " + std::to_string(uid) + " (elapsed: " + std::to_string(elapsed) + "ms)";
        OutputDebugStringA(("AgoraEventHandler::onUserJoined - " + msg + "\n").c_str());
    }

    void AgoraEventHandler::onUserOffline(uid_t uid, USER_OFFLINE_REASON_TYPE reason)
    {
        std::string reasonStr = (reason == USER_OFFLINE_QUIT) ? "QUIT" : 
                               (reason == USER_OFFLINE_DROPPED) ? "DROPPED" : "BECOME_AUDIENCE";
        std::string msg = "üë§ User offline: " + std::to_string(uid) + " (reason: " + reasonStr + ")";
        OutputDebugStringA(("AgoraEventHandler::onUserOffline - " + msg + "\n").c_str());
    }

    void AgoraEventHandler::onError(int err, const char* msg)
    {
        std::string errorMsg = "‚ùå Agora Error " + std::to_string(err) + ": " + std::string(msg ? msg : "Unknown error");
        OutputDebugStringA(("AgoraEventHandler::onError - " + errorMsg + "\n").c_str());
    }

    // AgoraManager implementation
    void AgoraManager::InitializeEngine(const std::string& appId)
    {
        try {
            OutputDebugStringA("üöÄ AgoraManager::InitializeEngine - Starting\n");
            OutputDebugStringA(("üì± App ID: " + appId + "\n").c_str());

            // Clean up existing engine
            if (m_rtcEngine) {
                OutputDebugStringA("üßπ Cleaning up existing engine\n");
                m_rtcEngine->leaveChannel();
                m_rtcEngine->release();
                m_rtcEngine = nullptr;
                OutputDebugStringA("‚úÖ Existing engine cleaned\n");
            }

            m_appId = appId;
            OutputDebugStringA("‚úÖ App ID stored\n");

            // Create event handler
            OutputDebugStringA("üîß Creating event handler...\n");
            m_eventHandler = std::make_unique<AgoraEventHandler>();
            if (!m_eventHandler) {
                OutputDebugStringA("‚ùå Failed to create event handler\n");
                return;
            }
            OutputDebugStringA("‚úÖ Event handler created\n");

            // Create engine
            OutputDebugStringA("üîß Creating RTC engine...\n");
            m_rtcEngine = createAgoraRtcEngine();
            if (!m_rtcEngine) {
                OutputDebugStringA("‚ùå Failed to create RTC engine\n");
                return;
            }
            OutputDebugStringA("‚úÖ RTC engine created successfully\n");

            // Initialize
            OutputDebugStringA("üîß Initializing engine with context...\n");
            RtcEngineContext context;
            context.appId = m_appId.c_str();
            context.eventHandler = m_eventHandler.get();
            context.channelProfile = agora::CHANNEL_PROFILE_COMMUNICATION;
            context.audioScenario = AUDIO_SCENARIO_DEFAULT;

            int result = m_rtcEngine->initialize(context);
            OutputDebugStringA(("üîç Initialize result: " + std::to_string(result) + "\n").c_str());
            
            if (result != 0) {
                OutputDebugStringA(("‚ùå Failed to initialize, error: " + std::to_string(result) + "\n").c_str());
                m_rtcEngine->release();
                m_rtcEngine = nullptr;
                m_isInitialized = false;
                return;
            }
            OutputDebugStringA("‚úÖ Engine initialized successfully\n");

            // Enable audio
            OutputDebugStringA("üîß Enabling audio...\n");
            result = m_rtcEngine->enableAudio();
            OutputDebugStringA(("üîç EnableAudio result: " + std::to_string(result) + "\n").c_str());

            // Set client role
            OutputDebugStringA("üîß Setting client role...\n");
            result = m_rtcEngine->setClientRole(CLIENT_ROLE_BROADCASTER);
            OutputDebugStringA(("üîç SetClientRole result: " + std::to_string(result) + "\n").c_str());

            // Mark as initialized
            m_isInitialized = true;
            OutputDebugStringA("‚úÖ AgoraManager::InitializeEngine - COMPLETED SUCCESSFULLY!\n");
            OutputDebugStringA(("‚úÖ m_isInitialized = " + std::string(m_isInitialized ? "true" : "false") + "\n").c_str());

        } catch (const std::exception& e) {
            OutputDebugStringA(("‚ùå Exception in InitializeEngine: " + std::string(e.what()) + "\n").c_str());
            m_isInitialized = false;
        } catch (...) {
            OutputDebugStringA("‚ùå Unknown exception in InitializeEngine\n");
            m_isInitialized = false;
        }
    }

    void AgoraManager::StartEchoTest()
    {
        try {
            OutputDebugStringA("üé§ AgoraManager::StartEchoTest - Starting Audio Device Loopback Test\n");
            OutputDebugStringA(("üîç m_isInitialized = " + std::string(m_isInitialized ? "true" : "false") + "\n").c_str());
            OutputDebugStringA(("üîç m_rtcEngine = " + std::string(m_rtcEngine ? "NOT NULL" : "NULL") + "\n").c_str());
            
            if (!m_isInitialized || !m_rtcEngine) {
                OutputDebugStringA("‚ùå Engine not initialized - CANNOT START ECHO TEST\n");
                return;
            }

            if (m_isEchoTestRunning) {
                OutputDebugStringA("‚ö†Ô∏è Echo test already running\n");
                return;
            }

            // Use AAudioDeviceManager class for Windows SDK
            OutputDebugStringA("üîß Creating AAudioDeviceManager...\n");
            agora::rtc::AAudioDeviceManager audioDeviceManager(m_rtcEngine);
            if (!audioDeviceManager) {
                OutputDebugStringA("‚ùå Failed to create audio device manager\n");
                return;
            }

            // Start audio device loopback test (perfect for Windows!)
            OutputDebugStringA("üîß Starting audio device loopback test...\n");
            int result = audioDeviceManager->startAudioDeviceLoopbackTest(1000); // 1 second interval
            
            if (result == 0) {
                m_isEchoTestRunning = true;
                OutputDebugStringA("‚úÖ Audio device loopback test started successfully!\n");
                OutputDebugStringA("üîä You should hear yourself through the loopback test!\n");
                OutputDebugStringA("üéß This is a direct device-level audio loopback!\n");
            } else {
                OutputDebugStringA(("‚ùå Failed to start audio device loopback test, error: " + std::to_string(result) + "\n").c_str());
            }

        } catch (const std::exception& e) {
            OutputDebugStringA(("‚ùå Exception in StartEchoTest: " + std::string(e.what()) + "\n").c_str());
        } catch (...) {
            OutputDebugStringA("‚ùå Unknown exception in StartEchoTest\n");
        }
    }

    void AgoraManager::StopEchoTest()
    {
        try {
            if (!m_rtcEngine || !m_isEchoTestRunning) return;
            
            OutputDebugStringA("üîß Stopping audio device loopback test...\n");
            
            // Use AAudioDeviceManager class for Windows SDK
            agora::rtc::AAudioDeviceManager audioDeviceManager(m_rtcEngine);
            if (!audioDeviceManager) {
                OutputDebugStringA("‚ùå Failed to create audio device manager\n");
                return;
            }
            
            // Stop the audio device loopback test
            int result = audioDeviceManager->stopAudioDeviceLoopbackTest();
            if (result == 0) {
                OutputDebugStringA("‚úÖ Audio device loopback test stopped successfully\n");
            } else {
                OutputDebugStringA(("‚ùå Failed to stop audio device loopback test, error: " + std::to_string(result) + "\n").c_str());
            }
            
            m_isEchoTestRunning = false;
            OutputDebugStringA("‚úÖ Echo test stopped\n");
        } catch (...) {
            OutputDebugStringA("‚ùå Exception in StopEchoTest\n");
        }
    }

    void AgoraManager::JoinChannel(const std::string& channelName)
    {
        try {
            if (!m_isInitialized || !m_rtcEngine) return;

            ChannelMediaOptions options;
            options.publishMicrophoneTrack = true;
            options.autoSubscribeAudio = true;
            options.autoSubscribeVideo = false;
            options.enableAudioRecordingOrPlayout = true;
            options.clientRoleType = CLIENT_ROLE_BROADCASTER;

            int result = m_rtcEngine->joinChannel(nullptr, channelName.c_str(), 0, options);
            if (result == 0) {
                m_currentChannel = channelName;
                OutputDebugStringA(("‚úÖ Joined channel: " + channelName + "\n").c_str());
            }
        } catch (...) {
            OutputDebugStringA("‚ùå Exception in JoinChannel\n");
        }
    }

    void AgoraManager::LeaveChannel()
    {
        try {
            if (!m_rtcEngine || m_currentChannel.empty()) return;
            
            m_rtcEngine->leaveChannel();
            m_currentChannel.clear();
            OutputDebugStringA("‚úÖ Left channel\n");
        } catch (...) {
            OutputDebugStringA("‚ùå Exception in LeaveChannel\n");
        }
    }

    void AgoraManager::ReleaseEngine()
    {
        try {
            if (m_rtcEngine) {
                if (!m_currentChannel.empty()) {
                    m_rtcEngine->leaveChannel();
                    m_currentChannel.clear();
                }
                m_rtcEngine->release();
                m_rtcEngine = nullptr;
            }
            m_eventHandler.reset();
            m_isInitialized = false;
            m_isEchoTestRunning = false;
            OutputDebugStringA("‚úÖ Engine released\n");
        } catch (...) {
            OutputDebugStringA("‚ùå Exception in ReleaseEngine\n");
        }
    }

    std::string AgoraManager::GetStatus()
    {
        std::string status = "üîß AGORA MANAGER STATUS:\n\n";
        
        if (m_rtcEngine) {
            status += "‚úÖ RTC Engine: CREATED\n";
        } else {
            status += "‚ùå RTC Engine: NOT CREATED\n";
        }

        if (m_isInitialized) {
            status += "‚úÖ Engine Status: INITIALIZED\n";
            status += "üì± App ID: " + m_appId + "\n";
        } else {
            status += "‚ùå Engine Status: NOT INITIALIZED\n";
        }

        if (!m_currentChannel.empty()) {
            status += "üîó Current Channel: " + m_currentChannel + "\n";
        } else {
            status += "‚≠ï Current Channel: NONE\n";
        }

        if (m_isEchoTestRunning) {
            status += "üé§ Echo Test: RUNNING\n";
        } else {
            status += "‚≠ï Echo Test: STOPPED\n";
        }

        if (m_isInitialized && m_rtcEngine) {
            status += "\nüéâ STATUS: READY FOR VOICE COMMUNICATION!";
        } else {
            status += "\n‚ö†Ô∏è STATUS: NEEDS INITIALIZATION";
        }

        return status;
    }
}